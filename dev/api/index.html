<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>API · AntennaFieldRepresentations.jl</title><meta name="title" content="API · AntennaFieldRepresentations.jl"/><meta property="og:title" content="API · AntennaFieldRepresentations.jl"/><meta property="twitter:title" content="API · AntennaFieldRepresentations.jl"/><meta name="description" content="Documentation for AntennaFieldRepresentations.jl."/><meta property="og:description" content="Documentation for AntennaFieldRepresentations.jl."/><meta property="twitter:description" content="Documentation for AntennaFieldRepresentations.jl."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img class="docs-light-only" src="../assets/logo.svg" alt="AntennaFieldRepresentations.jl logo"/><img class="docs-dark-only" src="../assets/logo-dark.svg" alt="AntennaFieldRepresentations.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">AntennaFieldRepresentations.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Representations</span><ul><li><input class="collapse-toggle" id="menuitem-2-1" type="checkbox"/><label class="tocitem" for="menuitem-2-1"><span class="docs-label">Dipoles</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../dipoles/dipole_theory/">Theory</a></li><li><a class="tocitem" href="../dipoles/dipole_examples/">Examples</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Spherical Vector Wave Expansion</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../spherical/spherical_theory/">Theory</a></li><li><a class="tocitem" href="../spherical/spherical_fast/">Fast Algorithms</a></li><li><a class="tocitem" href="../spherical/spherical_examples/">Examples</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-3" type="checkbox"/><label class="tocitem" for="menuitem-2-3"><span class="docs-label">Plane Wave Expansion</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../planewaves/planewave_theory/">Theory</a></li><li><a class="tocitem" href="../planewaves/planewave_examples/">Examples</a></li></ul></li><li><input class="collapse-toggle" id="menuitem-2-4" type="checkbox"/><label class="tocitem" for="menuitem-2-4"><span class="docs-label">Equivalent Surface Currents</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../surfacecurrents/surface_theory/">Theory</a></li><li><a class="tocitem" href="../surfacecurrents/surface_examples/">Examples</a></li></ul></li></ul></li><li><span class="tocitem">Operations</span><ul><li><a class="tocitem" href="../operations/fields/">Field Evaluations</a></li><li><a class="tocitem" href="../operations/coordinate_trafos/">Coordinate Transformations</a></li><li><a class="tocitem" href="../operations/conversions/">Conversions</a></li><li><a class="tocitem" href="../operations/interactions/">Transmissions</a></li></ul></li><li><a class="tocitem" href="../examples/">Examples</a></li><li class="is-active"><a class="tocitem" href>API</a><ul class="internal"><li><a class="tocitem" href="#Public-Types"><span>Public Types</span></a></li><li><a class="tocitem" href="#Public-Functions"><span>Public Functions</span></a></li><li><a class="tocitem" href="#Private-Functions-and-Types"><span>Private Functions and Types</span></a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>API</a></li></ul></nav><div class="docs-right"><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h1><h2 id="Public-Types"><a class="docs-heading-anchor" href="#Public-Types">Public Types</a><a id="Public-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Public-Types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.AbsorbedSphericalExpansion" href="#AntennaFieldRepresentations.AbsorbedSphericalExpansion"><code>AntennaFieldRepresentations.AbsorbedSphericalExpansion</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbsorbedSphericalExpansion{C&lt;:Complex} &lt;: AbstractSphericalExpansion</code></pre><p>Store spherical vector wave expansion coefficients for an expansion of absorbed type</p><p><strong>Fields</strong></p><ul><li><code>coefficients::Array{C,1}</code> : array storing the expansion coefficients</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.AbstractDipole" href="#AntennaFieldRepresentations.AbstractDipole"><code>AntennaFieldRepresentations.AbstractDipole</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type container type for HertzDipole and FitzgeraldDipole</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.AbstractSphericalExpansion" href="#AntennaFieldRepresentations.AbstractSphericalExpansion"><code>AntennaFieldRepresentations.AbstractSphericalExpansion</code></a> — <span class="docstring-category">Type</span></header><section><div><p>SphericalExpansions can be Radiating, Incident, or Absorbed</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.AbstractSurfaceCurrentDensity" href="#AntennaFieldRepresentations.AbstractSurfaceCurrentDensity"><code>AntennaFieldRepresentations.AbstractSurfaceCurrentDensity</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Abstract type container type for Surface current densities</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.FarfieldPattern" href="#AntennaFieldRepresentations.FarfieldPattern"><code>AntennaFieldRepresentations.FarfieldPattern</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Radiated far-field pattern sampled in angular domain. Sampling points lie on equiangular grid in ϕ and Gauß-Legendre grid in θ. Number and location of sampling points is defined by L. length(θ)=L+1 length(ϕ)=2L+2.</p><p><strong>Fields:</strong></p><p>k₀::Float64 : Wavenumber L::Int64 : Order of the representation Eθ::Array{&lt;:Complex,2} : matrix storing the complex values for the θ-components Eϕ::Array{&lt;:Complex,2} : matrix storing the complex values for the ϕ-components</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.FitzgeraldDipole" href="#AntennaFieldRepresentations.FitzgeraldDipole"><code>AntennaFieldRepresentations.FitzgeraldDipole</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">FitzgeraldDipole{T&lt;:Number} &lt;: AbstractDipole</code></pre><p>Store information for a magnetic dipole</p><p><strong>Fields</strong></p><ul><li><code>pos::SArray{Tuple{3},T,1,3}</code> : position (can be real or complex)</li><li><code>dir::SArray{Tuple{3},T,1,3}</code> : direction (must be complex to enable circular polarization)</li><li><code>mag::ComplexF64</code> : magnitude (for scalar excitation)</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.HertzDipole" href="#AntennaFieldRepresentations.HertzDipole"><code>AntennaFieldRepresentations.HertzDipole</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">HertzDipole{T&lt;:Number} &lt;: AbstractDipole</code></pre><p>Store information for an electric dipole</p><p><strong>Fields</strong></p><ul><li><code>pos::SArray{Tuple{3},T,1,3}</code> : position (can be real or complex)</li><li><code>dir::SArray{Tuple{3},T,1,3}</code> : direction (must be complex to enable circular polarization)</li><li><code>mag::ComplexF64</code> : magnitude (for scalar excitation)</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.IncidentSphericalExpansion" href="#AntennaFieldRepresentations.IncidentSphericalExpansion"><code>AntennaFieldRepresentations.IncidentSphericalExpansion</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IncidentSphericalExpansion{C&lt;:Complex} &lt;: AbstractSphericalExpansion</code></pre><p>Store spherical vector wave expansion coefficients for an expansion of incident type</p><p><strong>Fields</strong></p><ul><li><code>coefficients::Array{C,1}</code> : array storing the expansion coefficients</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.MLFMMInteractionMatrix" href="#AntennaFieldRepresentations.MLFMMInteractionMatrix"><code>AntennaFieldRepresentations.MLFMMInteractionMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">MLFMMInteractionMatrix{C} &lt;: LinearMaps.LinearMap{C}</code></pre><p>Represent interactions between array of dipole sources and array of dipole probes as abstract matrix</p><p><strong>Fields</strong></p><ul><li>sourcestruct::AntennaFieldRepresentations.MLFMMSource</li><li>receivestruct::AntennaFieldRepresentations.MLFMMReceive</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.PlaneWave" href="#AntennaFieldRepresentations.PlaneWave"><code>AntennaFieldRepresentations.PlaneWave</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Object for a single plane wave</p><p><strong>Fields:</strong></p><p>kvec::Array{&lt;:Number,1} : k-vector determining the propagation direction. If complex valued: Evanescent components pol::Array{&lt;:Number,1} : polarizatiion vector. If complex valued: elliptic polarization mag::Complex : Complex valued excitation amplitude</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.PlaneWaveSpectrum" href="#AntennaFieldRepresentations.PlaneWaveSpectrum"><code>AntennaFieldRepresentations.PlaneWaveSpectrum</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Incident plane-wave spectrum sampled in angular domain. Sampling points lie on equiangular grid in ϕ and Gauß-Legendre grid in θ. Number and location of sampling points is defined by L. length(θ)=L+1 length(ϕ)=2L+2.</p><p><strong>Fields:</strong></p><p>k₀::Float64 : Wavenumber L::Int64 : Order of the representation Eθ::Array{Complex{Float64},2} : matrix storing the complex values for the θ-components Eϕ::Array{Complex{Float64},2} : matrix storing the complex values for the ϕ-components </p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.RadiatingSphericalExpansion" href="#AntennaFieldRepresentations.RadiatingSphericalExpansion"><code>AntennaFieldRepresentations.RadiatingSphericalExpansion</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RadiatingSphericalExpansion{C&lt;:Complex} &lt;: AbstractSphericalExpansion</code></pre><p>Store spherical vector wave expansion coefficients for an expansion of radiating type</p><p><strong>Fields</strong></p><ul><li><code>coefficients::Array{C,1}</code> : array storing the expansion coefficients</li></ul></div></section></article><h2 id="Public-Functions"><a class="docs-heading-anchor" href="#Public-Functions">Public Functions</a><a id="Public-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Public-Functions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.Wacker-Union{Tuple{C}, Tuple{T}, Tuple{Array{C, 3}, Vector{T}}} where {T&lt;:Complex, C&lt;:Complex}" href="#AntennaFieldRepresentations.Wacker-Union{Tuple{C}, Tuple{T}, Tuple{Array{C, 3}, Vector{T}}} where {T&lt;:Complex, C&lt;:Complex}"><code>AntennaFieldRepresentations.Wacker</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Wacker(S12, αin, [θvec, weightvec])</code></pre><p>Return (receiving) spherical mode coefficients from measured S12 data with regular grid points on sphere. S12 is expected to have dimensions (L+1) × (2L+1) × 2 if no θvec or Jθ, JΦ, Jχ is given</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.Wackerforward-Union{Tuple{C}, Tuple{Vector{C}, Vector{C}, Integer, Integer}} where C&lt;:Complex" href="#AntennaFieldRepresentations.Wackerforward-Union{Tuple{C}, Tuple{Vector{C}, Vector{C}, Integer, Integer}} where C&lt;:Complex"><code>AntennaFieldRepresentations.Wackerforward</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Wackerforward(α_inc,  β_aut, Jθ, Jϕ[, Jχ])</code></pre><p>Return regularly sampled S12 measurement data on sphere.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.Wackerforward_ad-Union{Tuple{C}, Tuple{K}, Tuple{Vector{C}, Array{K, 3}, Integer, Integer, Integer}} where {K&lt;:Complex, C&lt;:Complex}" href="#AntennaFieldRepresentations.Wackerforward_ad-Union{Tuple{C}, Tuple{K}, Tuple{Vector{C}, Array{K, 3}, Integer, Integer, Integer}} where {K&lt;:Complex, C&lt;:Complex}"><code>AntennaFieldRepresentations.Wackerforward_ad</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Wackerforward_ad(α_inc, S21, Jθ, Jϕ, Jχ)</code></pre><p>Return adjoint operator to <code>Wackerforward(α_inc,  β_aut, Jθ, Jϕ, Jχ)</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.cdist-Tuple{Vector{&lt;:Real}}" href="#AntennaFieldRepresentations.cdist-Tuple{Vector{&lt;:Real}}"><code>AntennaFieldRepresentations.cdist</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cdist(R::Array{&lt;:Number,1}) -&gt; Number</code></pre><p>Return √(R⋅R) without complex conjugation of R in the dot product. Corresponds to the norm operator for real valued vectors</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.convertrepresentation" href="#AntennaFieldRepresentations.convertrepresentation"><code>AntennaFieldRepresentations.convertrepresentation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">convertrepresentation(newType&lt;:Type{FieldRepresentation}, fieldobject&lt;: FieldRepresentation, args)</code></pre><p>Convert field representation into other type with different datastructure.</p><p>Field evaluations of the respective old and new field representations should be approximately equal in a common region of convergence.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.converttype" href="#AntennaFieldRepresentations.converttype"><code>AntennaFieldRepresentations.converttype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">converttype(newType&lt;:Type{FieldRepresentation}, fieldobject&lt;: FieldRepresentation)</code></pre><p>Convert field representation into other type with same datastructure. Field avaluations of the respective old and new field representations will differ.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.efield-Tuple{Any, AbstractVector{&lt;:Number}, Number}" href="#AntennaFieldRepresentations.efield-Tuple{Any, AbstractVector{&lt;:Number}, Number}"><code>AntennaFieldRepresentations.efield</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">efield(fieldobject&lt;:FieldRepresentation, R, k₀::Number) -&gt; [Ex;Ey;Ez]
efield(Vector{&lt;:FieldRepresentation}, R, k₀::Number) -&gt; [Ex;Ey;Ez]</code></pre><p>Return the E-field vector (in cartesian coordinates) of the field representation at location R.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.ehfield-Tuple{Any, AbstractVector{&lt;:Number}, Number}" href="#AntennaFieldRepresentations.ehfield-Tuple{Any, AbstractVector{&lt;:Number}, Number}"><code>AntennaFieldRepresentations.ehfield</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ehfield(fieldobject&lt;:FieldRepresentation, R, k₀::Number) -&gt; [Ex;Ey;Ez], [Hx;Hy;Hz]
ehfield(Vector{&lt;:FieldRepresentation}, R, k₀::Number) -&gt; [Ex;Ey;Ez], [Hx;Hy;Hz]</code></pre><p>Return the E-field and H-field vector (in cartesian coordinates) of the field representation at location R.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.elementtype" href="#AntennaFieldRepresentations.elementtype"><code>AntennaFieldRepresentations.elementtype</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">elementtype(fieldobject&lt;:FieldRepresentation)</code></pre><p>Return base type of elements representing the fields in <code>fieldobject</code>. Default is ComplexF64</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.hfield-Tuple{Any, AbstractVector{&lt;:Number}, Number}" href="#AntennaFieldRepresentations.hfield-Tuple{Any, AbstractVector{&lt;:Number}, Number}"><code>AntennaFieldRepresentations.hfield</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">hfield(fieldobject&lt;:FieldRepresentation, R, k₀::Number) -&gt; [Hx;Hy;Hz]
hfield(Vector{&lt;:FieldRepresentation}, R, k₀::Number) -&gt; [Hx;Hy;Hz]</code></pre><p>Return the H-field vector (in cartesian coordinates) of the field representation at location R.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.j_to_sℓm-Tuple{Any}" href="#AntennaFieldRepresentations.j_to_sℓm-Tuple{Any}"><code>AntennaFieldRepresentations.j_to_sℓm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">j_to_sℓm(j)

Convert single index j to multi-index s ℓ m</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.reciprocaltype-Tuple{Type{&lt;:AbstractElectromagneticFieldRepresentation}}" href="#AntennaFieldRepresentations.reciprocaltype-Tuple{Type{&lt;:AbstractElectromagneticFieldRepresentation}}"><code>AntennaFieldRepresentations.reciprocaltype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">reciprocaltype(type::Type{&lt;:AbstractElectromagneticFieldRepresentation}) -&gt; Type{&lt;:AbstractElectromagneticFieldRepresentation}</code></pre><p>Return type of the field representation which is reciprocal to the input type.    </p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.resample-Tuple{FarfieldPattern, AntennaFieldRepresentations.AbstractInterpolationStrategy}" href="#AntennaFieldRepresentations.resample-Tuple{FarfieldPattern, AntennaFieldRepresentations.AbstractInterpolationStrategy}"><code>AntennaFieldRepresentations.resample</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">resample(pattern::PlaneWaveRepresentation, L::Integer, [orderθ::Integer=12, orderϕ::Integer=12]) -&gt; newpattern::PlaneWaveRepresentation</code></pre><p>Return pattern sampled according to order <code>L</code> using Lagrange interpolation of orders <code>orderθ</code>, <code>orderϕ</code>     </p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.revertdirection-Tuple{P} where P&lt;:PlaneWaveRepresentation" href="#AntennaFieldRepresentations.revertdirection-Tuple{P} where P&lt;:PlaneWaveRepresentation"><code>AntennaFieldRepresentations.revertdirection</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">revertdirection(pattern::PlaneWaveRepresentation) -&gt; pattern_revert::PlaneWaveRepresentation</code></pre><p>Return <code>PlaneWaveRepresentation</code> with reverted propagation directions. <strong>F</strong>(<strong>k</strong>) -&gt; <strong>F</strong>(-<strong>k</strong>)</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.rot_mat_zyz-Tuple{Number, Number, Number}" href="#AntennaFieldRepresentations.rot_mat_zyz-Tuple{Number, Number, Number}"><code>AntennaFieldRepresentations.rot_mat_zyz</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rot_mat_zyz(χ::Number, θ::Number, ϕ::Number)-&gt; R::Matrix{eltype(χ, θ, ϕ)}</code></pre><p>Return rotation matrix for cartesian vector components for a rotation around Euler angles <code>χ</code>, <code>θ</code>, <code>ϕ</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.rotate-Tuple{Any}" href="#AntennaFieldRepresentations.rotate-Tuple{Any}"><code>AntennaFieldRepresentations.rotate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rotate(fieldobject&lt;:FieldRepresentation, χ::Number, θ::Number, ϕ::Number) -&gt; rotatedfieldobject&lt;:Fieldrepresentation
rotate(fieldobject&lt;:FieldRepresentation; [χ=0.0],  [θ=0.0], [ϕ=0.0]) -&gt; rotatedfieldobject&lt;:Fieldrepresentation</code></pre><p>Rotate a field representation around the Euler angles <code>χ</code>, <code>θ</code>, <code>ϕ</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.samplingrule-Tuple{Integer}" href="#AntennaFieldRepresentations.samplingrule-Tuple{Integer}"><code>AntennaFieldRepresentations.samplingrule</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">samplingrule(L::Integer) -&gt; ( w::Array{Float64,1}, θ::Array{Float64,1}, ϕ::Array{Float64,1} )</code></pre><p>Return sampling points for θ, ϕ, and θ-integration weights w for a far field or plane wave spectrum of order L.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.shiftrepresentation" href="#AntennaFieldRepresentations.shiftrepresentation"><code>AntennaFieldRepresentations.shiftrepresentation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">shiftrepresentation(fieldobject&lt;:FieldRepresentation, R, k₀::Number) -&gt; newobject&lt;:Fieldrepresentation</code></pre><p>Translate field representation into field representation of same type in translated coordinate system with new origin at R. </p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.sqrtdot-Tuple{Any, Any}" href="#AntennaFieldRepresentations.sqrtdot-Tuple{Any, Any}"><code>AntennaFieldRepresentations.sqrtdot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sqrtdot(u::Array{&lt;:Number,1}, v::Array{&lt;:Number,1}) -&gt; Number</code></pre><p>Return √(u⋅v) without complex conjugation of u</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.sℓm_to_j-Tuple{Any, Any, Any}" href="#AntennaFieldRepresentations.sℓm_to_j-Tuple{Any, Any, Any}"><code>AntennaFieldRepresentations.sℓm_to_j</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sℓm_to_j(s,ℓ,m)

Convert multi-index s ℓ m to single index j</code></pre></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.translate" href="#AntennaFieldRepresentations.translate"><code>AntennaFieldRepresentations.translate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">translate(fieldobject&lt;:FieldRepresentation, R, k₀::Number) -&gt; newobject&lt;:Fieldrepresentation</code></pre><p>Translate radiating field representation into incident field representation in translated coordinate system with new origin at R. </p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.transmission-Union{Tuple{T}, Tuple{Any, T, Number}} where T&lt;:AbstractElectromagneticFieldRepresentation" href="#AntennaFieldRepresentations.transmission-Union{Tuple{T}, Tuple{Any, T, Number}} where T&lt;:AbstractElectromagneticFieldRepresentation"><code>AntennaFieldRepresentations.transmission</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">transmission(sender&lt;:FieldRepresentation, receiver&lt;:FieldRepresentation, k₀::Number) -&gt; val::Complex</code></pre><p>Return interaction between two field representations ( or source representations)</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.udot-Tuple{Vector{&lt;:Real}, Vector{&lt;:Real}}" href="#AntennaFieldRepresentations.udot-Tuple{Vector{&lt;:Real}, Vector{&lt;:Real}}"><code>AntennaFieldRepresentations.udot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dotu(u::Array{&lt;:Number,1}, v::Array{&lt;:Number,1}) -&gt; Number</code></pre><p>Return u⋅v without complex conjugation of u</p></div></section></article><h2 id="Private-Functions-and-Types"><a class="docs-heading-anchor" href="#Private-Functions-and-Types">Private Functions and Types</a><a id="Private-Functions-and-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Private-Functions-and-Types" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.EquiangularFarFieldPattern" href="#AntennaFieldRepresentations.EquiangularFarFieldPattern"><code>AntennaFieldRepresentations.EquiangularFarFieldPattern</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Far-field pattern sampled in angular domain. Sampling points lie on equiangular grid in ϕ and θ.</p><p><strong>Fields:</strong></p><p>k₀::Float64 Jθ::Integer : defines sampling density in θ: Δθ= 2π/Jθ Jϕ::Integer : defines sampling density in ϕ: Δϕ= 2π/Jϕ Eθ::Array{Complex{Float64},2} : matrix storing the complex values for the corresponding co polar plane wave Eϕ::Array{Complex{Float64},2} : matrix storing the complex values for the corresponding cross polar plane wave</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.UnorthodoxSphericalExpansion" href="#AntennaFieldRepresentations.UnorthodoxSphericalExpansion"><code>AntennaFieldRepresentations.UnorthodoxSphericalExpansion</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">UnorthodoxSphericalExpansion{C&lt;:Complex} &lt;: AbstractSphericalExpansion</code></pre><p>Store spherical vector wave expansion coefficients for an expansion of absorbed type</p><p><strong>Fields</strong></p><ul><li><code>coefficients::Array{C,1}</code> : array storing the expansion coefficients</li></ul></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.F_sℓm_cartesian-NTuple{6, Any}" href="#AntennaFieldRepresentations.F_sℓm_cartesian-NTuple{6, Any}"><code>AntennaFieldRepresentations.F_sℓm_cartesian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">F_sℓm_cartesian(s,ℓ,m,c,R,k0) -&gt; [Fx;Fy;Fz]</code></pre><p>Return normalized vector spherical wave function at R in cartesian coordinates </p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.F_sℓm_cartesian_array-Union{Tuple{N}, Tuple{Integer, Type{&lt;:AbstractSphericalExpansion}, AbstractArray{N}, Number}} where N&lt;:Number" href="#AntennaFieldRepresentations.F_sℓm_cartesian_array-Union{Tuple{N}, Tuple{Integer, Type{&lt;:AbstractSphericalExpansion}, AbstractArray{N}, Number}} where N&lt;:Number"><code>AntennaFieldRepresentations.F_sℓm_cartesian_array</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">F_sℓm_cartesian_array(s,ℓ,m,c,R,k0) -&gt; [Fx;Fy;Fz]</code></pre><p>Return normalized vector spherical wave function at R in cartesian coordinates </p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.F_sℓm_spherical-Tuple{Integer, Integer, Integer, Type{&lt;:AbstractSphericalExpansion}, Real, Number, Real, Real}" href="#AntennaFieldRepresentations.F_sℓm_spherical-Tuple{Integer, Integer, Integer, Type{&lt;:AbstractSphericalExpansion}, Real, Number, Real, Real}"><code>AntennaFieldRepresentations.F_sℓm_spherical</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">F_sℓm_spherical(s,ℓ, m,r,ϑ,φ) -&gt; [Fr;Fϑ;Fφ]</code></pre><p>Return normalized vector spherical wave function at r,ϑ,φ in spherical coordinates </p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.F_sℓm_spherical_array-Tuple{Integer, Type{&lt;:AbstractSphericalExpansion}, Real, Number, Real, Real}" href="#AntennaFieldRepresentations.F_sℓm_spherical_array-Tuple{Integer, Type{&lt;:AbstractSphericalExpansion}, Real, Number, Real, Real}"><code>AntennaFieldRepresentations.F_sℓm_spherical_array</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">F_sℓm_spherical_array(Jmaxxc,r,ϑ,φ, k0) -&gt; Fr[1:Jmaxx], Fϑ[1:Jmaxx], Fφ[1:Jmaxx]</code></pre><p>Return all spherical vector wave functions upt to Jmaxx at r, ϑ, φ in spherical coordinates</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.F_sℓm_spherical_rzero-Tuple{Integer, Integer, Integer, Type{&lt;:AbstractSphericalExpansion}, Number, Real, Real}" href="#AntennaFieldRepresentations.F_sℓm_spherical_rzero-Tuple{Integer, Integer, Integer, Type{&lt;:AbstractSphericalExpansion}, Number, Real, Real}"><code>AntennaFieldRepresentations.F_sℓm_spherical_rzero</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">F_sℓm_rzero(s,ℓ, m ,c,ϑ,φ, k0) -&gt; Fr,Fϑ,Fφ</code></pre><p>Catches special cases for r==0 Hansen p. 3245f.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.F_sℓm_thetapi-Tuple{Integer, Integer, Integer, Type{&lt;:AbstractSphericalExpansion}, Real, Real, Real}" href="#AntennaFieldRepresentations.F_sℓm_thetapi-Tuple{Integer, Integer, Integer, Type{&lt;:AbstractSphericalExpansion}, Real, Real, Real}"><code>AntennaFieldRepresentations.F_sℓm_thetapi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">F_sℓm_thetapi(s,ℓ,m,c,r,φ,k0) -&gt; Fr,Fϑ,Fφ</code></pre><p>Catches special cases for ϑ==pi Hansen p. 3245f.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.F_sℓm_thetazero-Tuple{Integer, Integer, Integer, Type{&lt;:AbstractSphericalExpansion}, Real, Real, Real}" href="#AntennaFieldRepresentations.F_sℓm_thetazero-Tuple{Integer, Integer, Integer, Type{&lt;:AbstractSphericalExpansion}, Real, Real, Real}"><code>AntennaFieldRepresentations.F_sℓm_thetazero</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">F_sℓm_thetazero(s,ℓ,m,c,r,φ,k0)- &gt; Fr,Fϑ,Fφ</code></pre><p>Catches special cases for ϑ==0 Hansen p. 3245f.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.Greensdivdiv-Tuple{Any, Any, Float64}" href="#AntennaFieldRepresentations.Greensdivdiv-Tuple{Any, Any, Float64}"><code>AntennaFieldRepresentations.Greensdivdiv</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Greensdivdiv(R::SArray{Tuple{3},C,1,3}, dipoledir, k₀::Float64) -&gt; SArray{Tuple{3},C,1,3}
Greensdivdiv(R::Array{&lt;:Number,3}, dipoledir, k₀::Float64) -&gt; Array{&lt;:Number,3}</code></pre><p>Return  dyadic operator (I+1/k² ∇∇) g₀(r,r&#39;) </p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.Greensrot-Tuple{Any, Any, Float64}" href="#AntennaFieldRepresentations.Greensrot-Tuple{Any, Any, Float64}"><code>AntennaFieldRepresentations.Greensrot</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Greensrot(R::SArray{Tuple{3},C,1,3}, dipoledir, k₀::Float64) -&gt; SArray{Tuple{3},C,1,3}   Greensrot(R::Array{&lt;:Number,3}, dipoledir, k₀::Float64) -&gt; Array{&lt;:Number,3}</p><p>Return dyadic operator ∇g₀(r,r&#39;) × I</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.K_sℓm-Union{Tuple{C}, Tuple{Integer, Integer, Integer, Number, Real}, Tuple{Integer, Integer, Integer, Number, Real, Type{C}}} where C&lt;:Complex" href="#AntennaFieldRepresentations.K_sℓm-Union{Tuple{C}, Tuple{Integer, Integer, Integer, Number, Real}, Tuple{Integer, Integer, Integer, Number, Real, Type{C}}} where C&lt;:Complex"><code>AntennaFieldRepresentations.K_sℓm</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">K_sℓm(s,ℓ,m,ϑ,φ) -&gt; Kϑ,Kφ</code></pre><p>Return farfield vector spherical wave function in spherical coordinates </p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.K_sℓm_array-Union{Tuple{C}, Tuple{Integer, Number, Real}, Tuple{Integer, Number, Real, Type{C}}} where C&lt;:Complex" href="#AntennaFieldRepresentations.K_sℓm_array-Union{Tuple{C}, Tuple{Integer, Number, Real}, Tuple{Integer, Number, Real, Type{C}}} where C&lt;:Complex"><code>AntennaFieldRepresentations.K_sℓm_array</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">K_sℓm_array(Jmaxx,ϑ,φ) -&gt; Kϑ[1:Jmaxx], Kφ[1:Jmaxx]</code></pre><p>Return farfield for all vector spherical wave functions up to Jmaxx in spherical coordinates</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.K_sℓm_thetapi-Tuple{Integer, Integer, Integer, Real}" href="#AntennaFieldRepresentations.K_sℓm_thetapi-Tuple{Integer, Integer, Integer, Real}"><code>AntennaFieldRepresentations.K_sℓm_thetapi</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">K_sℓm_thetapi(s,ℓ,m,c,φ) -&gt; Kϑ, Kφ</code></pre><p>Catches special cases for ϑ==π Hansen p. 329f.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.K_sℓm_thetazero-Union{Tuple{C}, Tuple{Integer, Integer, Integer, Real}, Tuple{Integer, Integer, Integer, Real, Type{C}}} where C&lt;:Complex" href="#AntennaFieldRepresentations.K_sℓm_thetazero-Union{Tuple{C}, Tuple{Integer, Integer, Integer, Real}, Tuple{Integer, Integer, Integer, Real, Type{C}}} where C&lt;:Complex"><code>AntennaFieldRepresentations.K_sℓm_thetazero</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">K_sℓm_thetazero(s,ℓ,m,c,φ) -&gt; Kϑ, Kφ</code></pre><p>Catches special cases for ϑ==0 Hansen p. 329f.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.Plm_deriv_array-Union{Tuple{I}, Tuple{T}, Tuple{I, I, T}} where {T&lt;:Number, I&lt;:Integer}" href="#AntennaFieldRepresentations.Plm_deriv_array-Union{Tuple{I}, Tuple{T}, Tuple{I, I, T}} where {T&lt;:Number, I&lt;:Integer}"><code>AntennaFieldRepresentations.Plm_deriv_array</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Plm_deriv_array(Lmax,m,x)</code></pre><p>Return unnormalized Associated Legendre polynomials and their derivaives up to Lmax</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations._adjoint_aggregate!-Tuple{AntennaFieldRepresentations.MLFMMSource, Vector{Vector{Int64}}}" href="#AntennaFieldRepresentations._adjoint_aggregate!-Tuple{AntennaFieldRepresentations.MLFMMSource, Vector{Vector{Int64}}}"><code>AntennaFieldRepresentations._adjoint_aggregate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_adjoint_aggregate!(A::MLFMMSource, aggregationlist::Vector{Vector{Int}})</code></pre><p>Perform adjoint operation (i.e., complex conjugate of transposed operation) of <code>_adjoint_aggregate!</code></p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations._adjoint_aggregate_leafnodes!-Tuple{AntennaFieldRepresentations.MLFMMSource}" href="#AntennaFieldRepresentations._adjoint_aggregate_leafnodes!-Tuple{AntennaFieldRepresentations.MLFMMSource}"><code>AntennaFieldRepresentations._adjoint_aggregate_leafnodes!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_adjoint_aggregate_leafnodes!(A::MLFMMSource)</code></pre><p>Perform the adjoint operation (i.e., conjugate of transposed operation) to <code>_aggregate_leafnodes!</code></p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations._adjoint_disaggregate!-Tuple{AntennaFieldRepresentations.MLFMMReceive, AbstractVector}" href="#AntennaFieldRepresentations._adjoint_disaggregate!-Tuple{AntennaFieldRepresentations.MLFMMReceive, AbstractVector}"><code>AntennaFieldRepresentations._adjoint_disaggregate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_adjoint_disaggregate!(A::MLFMMReceive, [y::AbstractVector])</code></pre><p>Perform adjoint operation (i.e., complex conjugate of transposed operation) of <code>_disaggregate!</code>#</p><p>If no vector <code>y</code> is given, the content in <code>A.bvector</code> is used for adjoint disaggregation.  Otherwise, <code>A.bvector</code> is overwritten by <code>y</code> before adjoint disaggregation.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations._adjoint_disaggregate_leafnodes!-Tuple{AntennaFieldRepresentations.MLFMMReceive}" href="#AntennaFieldRepresentations._adjoint_disaggregate_leafnodes!-Tuple{AntennaFieldRepresentations.MLFMMReceive}"><code>AntennaFieldRepresentations._adjoint_disaggregate_leafnodes!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_adjoint_disaggregate_leafnodes!(A::MLFMMReceive)</code></pre><p>Perform ajoint operation (i.e., complex conjugate of transposed operation) of <code>_disaggregate_leafnodes!</code></p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations._adjoint_forward!-Tuple{AntennaFieldRepresentations.MLFMMSource, AntennaFieldRepresentations.MLFMMReceive}" href="#AntennaFieldRepresentations._adjoint_forward!-Tuple{AntennaFieldRepresentations.MLFMMSource, AntennaFieldRepresentations.MLFMMReceive}"><code>AntennaFieldRepresentations._adjoint_forward!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_adjoint_forward!(sourcestruct::MLFMMSource, receivestruct::MLFMMReceive)</code></pre><p>Store the result of the adjoint matrix vector product in <code>sourcevector.xvector</code></p><p>If no vector <code>y</code> is given, <code>receivestruct.bvector</code> is used as tight vector. Otherwise, <code>receivestruct.bvector</code> is overwritten by the content of <code>y</code> before the operation is performed    </p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations._adjoint_transfer!-Tuple{AntennaFieldRepresentations.MLFMMSource, AntennaFieldRepresentations.MLFMMReceive}" href="#AntennaFieldRepresentations._adjoint_transfer!-Tuple{AntennaFieldRepresentations.MLFMMSource, AntennaFieldRepresentations.MLFMMReceive}"><code>AntennaFieldRepresentations._adjoint_transfer!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_adjoint_transfer!(sourcestruct::MLFMMSource, receivestruct::MLFMMReceive)</code></pre><p>Perform the adjoint operator (i.e., complex conjugate of transposed operator) of <code>transfer!</code></p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations._aggregate!-Tuple{AntennaFieldRepresentations.MLFMMSource, Vector{Vector{Int64}}}" href="#AntennaFieldRepresentations._aggregate!-Tuple{AntennaFieldRepresentations.MLFMMSource, Vector{Vector{Int64}}}"><code>AntennaFieldRepresentations._aggregate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_aggregate!(A::MLFMMSource, aggregationlist::Vector{Vector{Int}})</code></pre><p>Aggregate <code>A</code> according to aggregationlist.</p><p>The aggregationlist specifies for each level which nodes shall be aggregated.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations._aggregate_children!-Tuple{AntennaFieldRepresentations.MLFMMSource, Any}" href="#AntennaFieldRepresentations._aggregate_children!-Tuple{AntennaFieldRepresentations.MLFMMSource, Any}"><code>AntennaFieldRepresentations._aggregate_children!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_aggregate_children!(A::MLFMMSource, parentnode)</code></pre><p>Fill pattern storage of parentnode with aggregated pattern from all its children.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations._aggregate_leafnodes!-Tuple{AntennaFieldRepresentations.MLFMMSource}" href="#AntennaFieldRepresentations._aggregate_leafnodes!-Tuple{AntennaFieldRepresentations.MLFMMSource}"><code>AntennaFieldRepresentations._aggregate_leafnodes!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_aggregate_leafnodes!(A::MLFMMSource)</code></pre><p>Fill storage for leaf node patterns due to excitation vector <code>A.xvector</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations._aggregate_to_minlevel!-Tuple{AntennaFieldRepresentations.MLFMMSource, Any}" href="#AntennaFieldRepresentations._aggregate_to_minlevel!-Tuple{AntennaFieldRepresentations.MLFMMSource, Any}"><code>AntennaFieldRepresentations._aggregate_to_minlevel!</code></a> — <span class="docstring-category">Method</span></header><section><div><p><em>aggregate</em>to<em>minlevel!(A::MLFMMSource, [x::AbstractVector]; min</em>aggregationlevel::Integer=0)</p><p>Aggregate <code>A</code> up to min_aggregationlevel. </p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations._allocatenodepattern-Union{Tuple{S}, Tuple{R}, Tuple{Type{S}, AntennaFieldRepresentations.MLFMMTrees.AbstractMLFMMTree, Vector{&lt;:Integer}, Vector{Vector{Int64}}}} where {R&lt;:Real, S&lt;:Union{FarfieldPattern{Complex{R}}, PlaneWaveSpectrum{Complex{R}}}}" href="#AntennaFieldRepresentations._allocatenodepattern-Union{Tuple{S}, Tuple{R}, Tuple{Type{S}, AntennaFieldRepresentations.MLFMMTrees.AbstractMLFMMTree, Vector{&lt;:Integer}, Vector{Vector{Int64}}}} where {R&lt;:Real, S&lt;:Union{FarfieldPattern{Complex{R}}, PlaneWaveSpectrum{Complex{R}}}}"><code>AntennaFieldRepresentations._allocatenodepattern</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_allocatenodepattern(P::Type{S}, tree::MLFMMTrees.AbstractMLFMMTree, cutoffparameters::Vector{&lt;:Integer}, [transferlist::Vector{Vector{Int}}, minlevelel::Int]) where {R&lt;:Real, S&lt;:Union{PlaneWaveSpectrum{Complex{R}}, FarfieldPattern{Complex{R}}}}</code></pre><p>Allocate memory for intermediate representation of far field patterns for each node in tree. </p><p>If <code>transferlist</code> is provided, only node patterns which are relevant for translations are stored. If <code>minlevel</code> is provided, only node patterns up to minlevel are stored.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations._collectPl!-Union{Tuple{T}, Tuple{I}, Tuple{AbstractVector{T}, I, T}} where {I&lt;:Integer, T&lt;:Number}" href="#AntennaFieldRepresentations._collectPl!-Union{Tuple{T}, Tuple{I}, Tuple{AbstractVector{T}, I, T}} where {I&lt;:Integer, T&lt;:Number}"><code>AntennaFieldRepresentations._collectPl!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_collectPl!(Pℓstorage, Lmax,x)</code></pre><p>Return Legendre polynomials up to Lmax with preallocated storage</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations._cutoffparameter-Tuple{Any, Any, Any}" href="#AntennaFieldRepresentations._cutoffparameter-Tuple{Any, Any, Any}"><code>AntennaFieldRepresentations._cutoffparameter</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_cutoffparameter(diameter, expectedaccuracy, k0)</code></pre><p>Return cutoff parameter (i.e., maximum spherical mode index L) to represent sources inside sphere of given <code>diameter</code> with expected accuracy.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations._disaggregate!-Tuple{AntennaFieldRepresentations.MLFMMReceive}" href="#AntennaFieldRepresentations._disaggregate!-Tuple{AntennaFieldRepresentations.MLFMMReceive}"><code>AntennaFieldRepresentations._disaggregate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_disaggregate!(receivestruct::MLFMMReceive)</code></pre><p>Perform all disaggregations according to <code>receivestruct.disaggregationlist</code>. The <code>receivestruct.disaggregationlist</code> stores all nodes at each level which shall perform a disaggregation.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations._disaggregate_children!-Tuple{Any, Any}" href="#AntennaFieldRepresentations._disaggregate_children!-Tuple{Any, Any}"><code>AntennaFieldRepresentations._disaggregate_children!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_disaggregate_children!(receivestruct, parentnode)</code></pre><p>Disaggregate pattern of parentnode to all its children and store the resulting patterns in <code>receivestruct.nodespectra[child]</code></p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations._disaggregate_leafnodes!-Tuple{AntennaFieldRepresentations.MLFMMReceive}" href="#AntennaFieldRepresentations._disaggregate_leafnodes!-Tuple{AntennaFieldRepresentations.MLFMMReceive}"><code>AntennaFieldRepresentations._disaggregate_leafnodes!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_disaggregate_leafnodes!(receivestruct::MLFMMReceive)</code></pre><p>Test leaf node patterns with all test functions of corresponding leafnode and store result in <code>receivestruct.bvector</code></p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations._extract_θ_row!-Union{Tuple{C}, Tuple{Any, Any, Matrix{C}, Matrix{C}, Any, AbstractVector}} where C&lt;:Complex" href="#AntennaFieldRepresentations._extract_θ_row!-Union{Tuple{C}, Tuple{Any, Any, Matrix{C}, Matrix{C}, Any, AbstractVector}} where C&lt;:Complex"><code>AntennaFieldRepresentations._extract_θ_row!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_extract_θ_row!(storage, Ematr::Array{C,2}, iθrange, wθ::&lt;:AbstractVector) where {C&lt;:Complex}</code></pre><p>Use interpolation weights <code>wθ</code> and correctly mapped range &#39;iθrange&#39; to extract values for all plane waves in certain θ-cut from matrix of <code>PlaneWaveRepresentation</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations._forward!-Tuple{AntennaFieldRepresentations.MLFMMSource, AntennaFieldRepresentations.MLFMMReceive}" href="#AntennaFieldRepresentations._forward!-Tuple{AntennaFieldRepresentations.MLFMMSource, AntennaFieldRepresentations.MLFMMReceive}"><code>AntennaFieldRepresentations._forward!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_forward!(sourcestruct::MLFMMSource, receivestruct::MLFMMReceive,[x])</code></pre><p>Store the result of the matrix vector product in <code>receivestruct.bvector</code></p><p>If no vector <code>x</code> is given, <code>sourcestruct.xvector</code> is used as excitation vector. Otherwise, <code>sourcestruct.xvector</code> is overwritten by the content of <code>x</code> before the operation is performed</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations._getpoints-Tuple{AbstractSurfaceCurrentDensity}" href="#AntennaFieldRepresentations._getpoints-Tuple{AbstractSurfaceCurrentDensity}"><code>AntennaFieldRepresentations._getpoints</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_getpoints(basisfunctions)</code></pre><p>Return list of <code>SVector{3}</code> representing the reference (i.e., center) locations of the <code>basisfunctions</code></p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations._getsourcefunctions-Union{Tuple{@NamedTuple{sourcefunctions::V1, points::V2}}, Tuple{V2}, Tuple{V1}} where {V1, V2}" href="#AntennaFieldRepresentations._getsourcefunctions-Union{Tuple{@NamedTuple{sourcefunctions::V1, points::V2}}, Tuple{V2}, Tuple{V1}} where {V1, V2}"><code>AntennaFieldRepresentations._getsourcefunctions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_getsourcefunctions(basisfunctions)</code></pre><p>Return list of individual source functions</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations._initialize_aggregationlist-Tuple{AntennaFieldRepresentations.MLFMMTrees.AbstractMLFMMTree, Any}" href="#AntennaFieldRepresentations._initialize_aggregationlist-Tuple{AntennaFieldRepresentations.MLFMMTrees.AbstractMLFMMTree, Any}"><code>AntennaFieldRepresentations._initialize_aggregationlist</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_initialize_aggregationlist(TXtree::MLFMMTrees.AbstractMLFMMTree, transferlist)</code></pre><p>Return a list of nodes per level which shall be aggregated to be able to perform all transfers provided in <code>transferlist</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations._initialize_disaggregationlist-Tuple{AntennaFieldRepresentations.MLFMMTrees.AbstractMLFMMTree, Any}" href="#AntennaFieldRepresentations._initialize_disaggregationlist-Tuple{AntennaFieldRepresentations.MLFMMTrees.AbstractMLFMMTree, Any}"><code>AntennaFieldRepresentations._initialize_disaggregationlist</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_initialize_disaggregationlist(RXtree::MLFMMTrees.AbstractMLFMMTree, transferlist)</code></pre><p>Return a list of nodes per level which shall be disaggregated to be able to perform all  disaggregations from nodes which receive transfers provided in <code>transferlist</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations._initialize_transferlist-Tuple{AntennaFieldRepresentations.MLFMMTrees.AbstractMLFMMTree, AntennaFieldRepresentations.MLFMMTrees.AbstractMLFMMTree}" href="#AntennaFieldRepresentations._initialize_transferlist-Tuple{AntennaFieldRepresentations.MLFMMTrees.AbstractMLFMMTree, AntennaFieldRepresentations.MLFMMTrees.AbstractMLFMMTree}"><code>AntennaFieldRepresentations._initialize_transferlist</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_initialize_transferlist(TXtree::MLFMMTrees.AbstractMLFMMTree, RXtree::MLFMMTrees.AbstractMLFMMTree; num_bufferboxes::Integer=1)</code></pre><p>For each node in <code>RXtree</code>, return a list of all transmit nodes in <code>TXtree</code> which shall perform a transfer to the receive node.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations._initialize_tree-Union{Tuple{R}, Tuple{AbstractArray{StaticArraysCore.SVector{3, R}}, R}} where R&lt;:Real" href="#AntennaFieldRepresentations._initialize_tree-Union{Tuple{R}, Tuple{AbstractArray{StaticArraysCore.SVector{3, R}}, R}} where R&lt;:Real"><code>AntennaFieldRepresentations._initialize_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_initialize_tree(points::AbstractArray{SVector{3,R}}, minhalfsize::R) where{R&lt;:Real}</code></pre><p>Assemble &#39;MLFMMTree&#39; based on point cloud and half length of leave boxes</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations._initializebasisfunctionfarfields-Union{Tuple{I}, Tuple{S}, Tuple{R}, Tuple{AntennaFieldRepresentations.MLFMMTrees.AbstractMLFMMTree, S, Vector{I}, R, Bool}} where {R&lt;:Real, S&lt;:AbstractSurfaceCurrentDensity, I&lt;:Int64}" href="#AntennaFieldRepresentations._initializebasisfunctionfarfields-Union{Tuple{I}, Tuple{S}, Tuple{R}, Tuple{AntennaFieldRepresentations.MLFMMTrees.AbstractMLFMMTree, S, Vector{I}, R, Bool}} where {R&lt;:Real, S&lt;:AbstractSurfaceCurrentDensity, I&lt;:Int64}"><code>AntennaFieldRepresentations._initializebasisfunctionfarfields</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_initializebasisfunctionfarfields(tree::MLFMMTrees.AbstractMLFMMTree, basisfunctions::S, cutoffparameters::Vector{I}, k0::R, verbose::Bool) where {R&lt;:Real, S&lt;:AbstractSurfaceCurrentDensity, I&lt;:Int}</code></pre><p>Return list of far fields for every basis function on leaf level.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations._initializebasisfunctionweightingpatterns-Union{Tuple{R}, Tuple{AntennaFieldRepresentations.MLFMMTrees.AbstractMLFMMTree, Any, Vector{&lt;:Integer}, R, Bool}} where R&lt;:Real" href="#AntennaFieldRepresentations._initializebasisfunctionweightingpatterns-Union{Tuple{R}, Tuple{AntennaFieldRepresentations.MLFMMTrees.AbstractMLFMMTree, Any, Vector{&lt;:Integer}, R, Bool}} where R&lt;:Real"><code>AntennaFieldRepresentations._initializebasisfunctionweightingpatterns</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_initializebasisfunctionweightingpatterns(tree::MLFMMTrees.AbstractMLFMMTree, functionspace,
cutoffparameters::Vector{&lt;:Integer}, k0::R, verbose::Bool) where{R&lt;:Real}</code></pre><p>Return list of far fields for every test function on leaf level stored in reverted direction feasible for testing incident plane wave spectra. </p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations._initializelevelcutoffparameters-Tuple{AntennaFieldRepresentations.MLFMMTrees.AbstractMLFMMTree, Any, Any}" href="#AntennaFieldRepresentations._initializelevelcutoffparameters-Tuple{AntennaFieldRepresentations.MLFMMTrees.AbstractMLFMMTree, Any, Any}"><code>AntennaFieldRepresentations._initializelevelcutoffparameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_initializelevelcutoffparameters(tree::MLFMMTrees.AbstractMLFMMTree, expectedaccuracy, wavenumber)</code></pre><p>Return list of cutoff parameters for each level in <code>tree</code> to represent the node farfields with expected accuracy.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations._initializelevelinterpolators-Tuple{Type{&lt;:Real}, AntennaFieldRepresentations.MLFMMTrees.AbstractMLFMMTree, Integer, Integer, Vector{&lt;:Integer}}" href="#AntennaFieldRepresentations._initializelevelinterpolators-Tuple{Type{&lt;:Real}, AntennaFieldRepresentations.MLFMMTrees.AbstractMLFMMTree, Integer, Integer, Vector{&lt;:Integer}}"><code>AntennaFieldRepresentations._initializelevelinterpolators</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_initializelevelinterpolators(R::Type{&lt;:Real}, tree::MLFMMTrees.AbstractMLFMMTree, orderθ::Integer, orderϕ::Integer,cutoffparameters::Vector{&lt;:Integer}; minlevel::Int=0)</code></pre><p>Return list of interpolators to aggregate from each level to the respective parent level.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations._initializetransferplan-Union{Tuple{P}, Tuple{Vector{Vector{Int64}}, AntennaFieldRepresentations.MLFMMSource, AntennaFieldRepresentations.MLFMMTrees.AbstractMLFMMTree}} where P&lt;:(Type{&lt;:AntennaFieldRepresentations.AbstractTransfer})" href="#AntennaFieldRepresentations._initializetransferplan-Union{Tuple{P}, Tuple{Vector{Vector{Int64}}, AntennaFieldRepresentations.MLFMMSource, AntennaFieldRepresentations.MLFMMTrees.AbstractMLFMMTree}} where P&lt;:(Type{&lt;:AntennaFieldRepresentations.AbstractTransfer})"><code>AntennaFieldRepresentations._initializetransferplan</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_initializetransferplan(transferlist::Vector{Vector{Int}}, sourcestruct::MLFMMSource, RXtree::MLFMMTrees.AbstractMLFMMTree;  ) where{P&lt;:Type{&lt;:AbstractTransfer}}</code></pre><p>For each planned transfer, initialize and store a transferobject which holds all rewuired information to calculate the corresponding far field transfer.</p><p><strong>Keywordarguments:</strong></p><p>transfertype::P=PlannedTransfer{Complex{R}} : specify type of the initialized tranfer object</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations._phaseshiftmatrix!-Tuple{AbstractMatrix, AbstractVector, Number}" href="#AntennaFieldRepresentations._phaseshiftmatrix!-Tuple{AbstractMatrix, AbstractVector, Number}"><code>AntennaFieldRepresentations._phaseshiftmatrix!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_phaseshiftmatrix!(storagematrix, R, k₀)</code></pre><p>In-place calculation of phaseshiftmatrix which needs to be element-wise multiplied to farfield to shift the farfield to new coordinate origin at R. Assumes that size(storagematrix) mathces the matrices in PlaneWaveRepresentation.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations._transfer!-Tuple{AntennaFieldRepresentations.MLFMMSource, AntennaFieldRepresentations.MLFMMReceive}" href="#AntennaFieldRepresentations._transfer!-Tuple{AntennaFieldRepresentations.MLFMMSource, AntennaFieldRepresentations.MLFMMReceive}"><code>AntennaFieldRepresentations._transfer!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_transfer!(sourcestruct::MLFMMSource, receivestruct::MLFMMReceive)</code></pre><p>Perform all required transfers between the <code>sourcestruct</code> and the <code>receivestruct</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations._transpose_aggregate!-Tuple{AntennaFieldRepresentations.MLFMMSource, Vector{Vector{Int64}}}" href="#AntennaFieldRepresentations._transpose_aggregate!-Tuple{AntennaFieldRepresentations.MLFMMSource, Vector{Vector{Int64}}}"><code>AntennaFieldRepresentations._transpose_aggregate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_transpose_aggregate!(A::MLFMMSource, aggregationlist::Vector{Vector{Int}})</code></pre><p>Perform transpose operation of <code>_aggregate!</code></p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations._transpose_aggregate_children!-Tuple{Any, Any}" href="#AntennaFieldRepresentations._transpose_aggregate_children!-Tuple{Any, Any}"><code>AntennaFieldRepresentations._transpose_aggregate_children!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_transpose_aggregate_children!(A, parentnode)</code></pre><p>Perform transposed operation to <code>_aggregate_children!</code></p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations._transpose_aggregate_leafnodes!-Tuple{AntennaFieldRepresentations.MLFMMSource}" href="#AntennaFieldRepresentations._transpose_aggregate_leafnodes!-Tuple{AntennaFieldRepresentations.MLFMMSource}"><code>AntennaFieldRepresentations._transpose_aggregate_leafnodes!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_transpose_aggregate_leafnodes!(A::MLFMMSource)</code></pre><p>Perform the transpose operation to <code>_aggregate_leafnodes!</code></p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations._transpose_disaggregate!-Tuple{AntennaFieldRepresentations.MLFMMReceive, AbstractVector}" href="#AntennaFieldRepresentations._transpose_disaggregate!-Tuple{AntennaFieldRepresentations.MLFMMReceive, AbstractVector}"><code>AntennaFieldRepresentations._transpose_disaggregate!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_transpose_disaggregate!(A::MLFMMReceive, [y::AbstractVector])

Perform transposed operation of `_disaggregate!`</code></pre><p>If no vector <code>y</code> is given, the content in <code>A.bvector</code> is used for transposed disaggregation.  Otherwise, <code>A.bvector</code> is overwritten by <code>y</code> before transposed disaggregation.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations._transpose_disaggregate_children!-Tuple{Any, Any}" href="#AntennaFieldRepresentations._transpose_disaggregate_children!-Tuple{Any, Any}"><code>AntennaFieldRepresentations._transpose_disaggregate_children!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_transpose_disaggregate_children!(A, parentnode)</code></pre><p>Perform transposed operation to <code>disaggrgate_children!</code></p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations._transpose_disaggregate_leafnodes!-Tuple{AntennaFieldRepresentations.MLFMMReceive}" href="#AntennaFieldRepresentations._transpose_disaggregate_leafnodes!-Tuple{AntennaFieldRepresentations.MLFMMReceive}"><code>AntennaFieldRepresentations._transpose_disaggregate_leafnodes!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_transpose_disaggregate_leafnodes!(A::MLFMMReceive)</code></pre><p>Perform transposed operation to <code>disaggregate_leafnodes!</code></p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations._transpose_forward!-Tuple{AntennaFieldRepresentations.MLFMMSource, AntennaFieldRepresentations.MLFMMReceive}" href="#AntennaFieldRepresentations._transpose_forward!-Tuple{AntennaFieldRepresentations.MLFMMSource, AntennaFieldRepresentations.MLFMMReceive}"><code>AntennaFieldRepresentations._transpose_forward!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_transpose_forward!(sourcestruct::MLFMMSource, receivestruct::MLFMMReceive, [y])</code></pre><p>Store the result of the transposed matrix vector product in <code>sourcevector.xvector</code></p><p>If no vector <code>y</code> is given, <code>receivestruct.bvector</code> is used as tight vector. Otherwise, <code>receivestruct.bvector</code> is overwritten by the content of <code>y</code> before the operation is performed</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations._transpose_transfer!-Tuple{AntennaFieldRepresentations.MLFMMSource, AntennaFieldRepresentations.MLFMMReceive}" href="#AntennaFieldRepresentations._transpose_transfer!-Tuple{AntennaFieldRepresentations.MLFMMSource, AntennaFieldRepresentations.MLFMMReceive}"><code>AntennaFieldRepresentations._transpose_transfer!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">_transpose_transfer!(sourcestruct::MLFMMSource, receivestruct::MLFMMReceive)</code></pre><p>Perform the transposed operator to <code>transfer!</code></p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.collectPl-Union{Tuple{T}, Tuple{I}, Tuple{I, T}} where {I&lt;:Integer, T&lt;:Number}" href="#AntennaFieldRepresentations.collectPl-Union{Tuple{T}, Tuple{I}, Tuple{I, T}} where {I&lt;:Integer, T&lt;:Number}"><code>AntennaFieldRepresentations.collectPl</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">collectPl(Lmax,x)</code></pre><p>Return Legendre polynomials up to Lmax</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.extract_single_planewave-Union{Tuple{C}, Tuple{Matrix{C}, Matrix{C}, Any, Vector{&lt;:Real}, Any, Vector{&lt;:Real}}} where C&lt;:Complex" href="#AntennaFieldRepresentations.extract_single_planewave-Union{Tuple{C}, Tuple{Matrix{C}, Matrix{C}, Any, Vector{&lt;:Real}, Any, Vector{&lt;:Real}}} where C&lt;:Complex"><code>AntennaFieldRepresentations.extract_single_planewave</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">extract_single_planewave(Eθmatr::Array{&lt;:Complex,2}, Eϕmatr::Array{&lt;:Complex,2}, iθrange, wθ, iϕrange, wϕ ) -&gt; Eθ, Eϕ</code></pre><p>Use interpolation weights <code>wθ</code>, <code>wϕ</code> and correctly mapped ranges &#39;iθrange&#39;, <code>iϕrange</code> to extract Eθ- and Eϕ- value for single plane wave from <code>PlaneWaveRepresentation</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.find_next_smaller_θind-Tuple{Vector{&lt;:Real}, Real}" href="#AntennaFieldRepresentations.find_next_smaller_θind-Tuple{Vector{&lt;:Real}, Real}"><code>AntennaFieldRepresentations.find_next_smaller_θind</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">find_next_smaller_θind(θvec::Array{&lt;:Real,1}, θnew&lt;:Real) -&gt; i::Integer</code></pre><p>Return index of largest entry in ascendingly ordered θvec which is still smaller than θnew</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.find_next_smaller_ϕind-Tuple{Real, Real}" href="#AntennaFieldRepresentations.find_next_smaller_ϕind-Tuple{Real, Real}"><code>AntennaFieldRepresentations.find_next_smaller_ϕind</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">find_next_smaller_ϕind(Δϕ&lt;:Real, ϕnew&lt;:Real)-&gt; i::Integer</code></pre><p>Return index of largest entry in ascendingly ordered ϕvec which is still smaller than ϕnew</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.g₀-Tuple{Array{&lt;:Number, 3}, Float64}" href="#AntennaFieldRepresentations.g₀-Tuple{Array{&lt;:Number, 3}, Float64}"><code>AntennaFieldRepresentations.g₀</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">g₀(R, k₀) -&gt; Number</code></pre><p>Scalar Greens function exp(-j<em>k₀</em>R)/(4<em>π</em>R)</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.interpolate_single_planewave-Union{Tuple{T}, Tuple{orderϕ}, Tuple{orderθ}, Tuple{Lnew}, Tuple{Lold}, Tuple{Real, Real, PlaneWaveRepresentation, AntennaFieldRepresentations.LocalInterpolation{Lold, Lnew, orderθ, orderϕ, T}}} where {Lold, Lnew, orderθ, orderϕ, T}" href="#AntennaFieldRepresentations.interpolate_single_planewave-Union{Tuple{T}, Tuple{orderϕ}, Tuple{orderθ}, Tuple{Lnew}, Tuple{Lold}, Tuple{Real, Real, PlaneWaveRepresentation, AntennaFieldRepresentations.LocalInterpolation{Lold, Lnew, orderθ, orderϕ, T}}} where {Lold, Lnew, orderθ, orderϕ, T}"><code>AntennaFieldRepresentations.interpolate_single_planewave</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">interpolate_single_planewave(θnew::Real, ϕnew::Real, pattern::PlaneWaveRepresentation, ::AbstractInterpolationStrategy)</code></pre><p>Interpolate single plane wave into direction <code>θnew</code>, <code>ϕnew</code> from given <code>PlaneWaveRepresentation</code> using plynomial (Legendre) interpolation of order <code>orderθ</code> in θ and <code>orderϕ</code> in ϕ. </p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.lagrange_barycentric_weights-Tuple{Any}" href="#AntennaFieldRepresentations.lagrange_barycentric_weights-Tuple{Any}"><code>AntennaFieldRepresentations.lagrange_barycentric_weights</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lagrange_barycentric_weights(X::Array{&lt;:Number,1}) -&gt; w::Array{&lt;:Number,1}</code></pre><p>Return barycentric weights for calculating Lagrange interpolation weights</p><p><strong>Extended help</strong></p><p>The barycentric weights are needed to evaluate the &quot;second (true) form of the barycentric formula&quot; for the Lagrange interpolation. See J.-P. Berrut and L. N. Trefethen: &quot;Barycentric Lagrange Interpolation&quot;, SIAM Review, Vol. 46, No. 3, pp. 501-517</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.lagrange_interpolation_weights-Union{Tuple{T}, Tuple{Any, T}} where T&lt;:Number" href="#AntennaFieldRepresentations.lagrange_interpolation_weights-Union{Tuple{T}, Tuple{Any, T}} where T&lt;:Number"><code>AntennaFieldRepresentations.lagrange_interpolation_weights</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">lagrange_interpolation_weights(X::Array{::Number,1},Y::Array{::Number,1},t::Number) -&gt; w::Array{Flota64}</code></pre><p>Return interpolation weights wᵢ for the calculation f(t)= ∑ᴺᵢ₌₁ wᵢ⋅ f(xᵢ) </p><p><strong>Extended help</strong></p><p>The interpolation weights are obtained using the &quot;second (true) form of the barycentric formula&quot;. See J.-P. Berrut and L. N. Trefethen: &quot;Barycentric Lagrange Interpolation&quot;, SIAM Review, Vol. 46, No. 3, pp. 501-517</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.legendre_deps_array-Union{Tuple{T}, Tuple{Integer, Integer, T}} where T&lt;:Number" href="#AntennaFieldRepresentations.legendre_deps_array-Union{Tuple{T}, Tuple{Integer, Integer, T}} where T&lt;:Number"><code>AntennaFieldRepresentations.legendre_deps_array</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">legendre_deps_array(m , Lmax, ϑ)</code></pre><p>Return the theta dependencies occuring in the spherical wave expansion</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.map_θrange!-Tuple{Any, Integer}" href="#AntennaFieldRepresentations.map_θrange!-Tuple{Any, Integer}"><code>AntennaFieldRepresentations.map_θrange!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">map_θrange!(iθrange, Nθ)</code></pre><p>Map the index range <code>iθrange</code> to values between <code>-Nθ+1</code> and  <code>Nθ</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.map_ϕrange!-Tuple{Any, Integer}" href="#AntennaFieldRepresentations.map_ϕrange!-Tuple{Any, Integer}"><code>AntennaFieldRepresentations.map_ϕrange!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">map_ϕrange!(iϕrange, Nθ)</code></pre><p>Map the index range <code>iϕrange</code> to values between <code>1</code> and  <code>Nϕ</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.sphPlm_deriv_array-Union{Tuple{I}, Tuple{T}, Tuple{I, I, T}} where {T&lt;:Number, I&lt;:Integer}" href="#AntennaFieldRepresentations.sphPlm_deriv_array-Union{Tuple{I}, Tuple{T}, Tuple{I, I, T}} where {T&lt;:Number, I&lt;:Integer}"><code>AntennaFieldRepresentations.sphPlm_deriv_array</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sphPlm_deriv_array(Lmax,m,x)</code></pre><p>Return normalized Associated Legendre polynomials and their derivaives up to Lmax sphPlm= 1/√(2π)  √((2ℓ+1)(ℓ-m)!/(2(ℓ+m)!)  Plm</p><p>From <a href="https://arxiv.org/abs/1410.1748">T. Limpanuparb, J. Milthorpe: &quot;Associated Legendre Polynomials and Spherical Harmonics Computation for Chemistry Applications&quot;, arXiv 2014</a></p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.αinc_PW-Tuple{Integer}" href="#AntennaFieldRepresentations.αinc_PW-Tuple{Integer}"><code>AntennaFieldRepresentations.αinc_PW</code></a> — <span class="docstring-category">Method</span></header><section><div><p>αinc_PW(L::Integer)</p><p>Return incident spherical mode coefficients up to mode order L of an x-polarized plane wave traveling in negative z-direction. Compare Hansen: &quot;Spherical Near-Field Measurements&quot; Appendix A1.6 </p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.θsequence-Tuple{Vector{&lt;:Real}, Any}" href="#AntennaFieldRepresentations.θsequence-Tuple{Vector{&lt;:Real}, Any}"><code>AntennaFieldRepresentations.θsequence</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">θsequence(θvec::Array{&lt;:Real, 1}, iθrange::Array{&lt;:Integer,1})</code></pre><p>Truncate and/or periodically extend <code>θvec</code> to create <code>θsequence</code> matching the index range in <code>iθrange</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="AntennaFieldRepresentations.MLFMMTrees.getboundingbox-Union{Tuple{AbstractArray{StaticArraysCore.SVector{D, F}, 1}}, Tuple{F}, Tuple{D}} where {D, F}" href="#AntennaFieldRepresentations.MLFMMTrees.getboundingbox-Union{Tuple{AbstractArray{StaticArraysCore.SVector{D, F}, 1}}, Tuple{F}, Tuple{D}} where {D, F}"><code>AntennaFieldRepresentations.MLFMMTrees.getboundingbox</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getboundingbox(points::Vector{SVector{D, F}})</code></pre><p>Returns halfsize and center of bounding box of points. The halfsize is the half of the length of the edge of the bounding box.</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../examples/">« Examples</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.2.1 on <span class="colophon-date" title="Wednesday 31 January 2024 22:45">Wednesday 31 January 2024</span>. Using Julia version 1.10.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
